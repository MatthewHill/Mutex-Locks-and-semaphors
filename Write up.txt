The part 1 program works without using any sort of locks.  This program has a tendency to fail around 11 digits in, usually by attempting to replace the next value in the buffer with the previous value that it had, but occasionally failing earlier, later or with different values.
I made a buffer size of 10, and worked my way up the buffer with my insert values until I reached the end and then cycled back to the beggining.  This ensured that they would be taken out in the same order they are taken in.  With a buffer size this small, the program had a tendency to fill up the buffer before context switching.  In the main function a thread is created for both a consumer and a producer process.  The producer thread will exit once it succeeds in placing all values ( this never happened) and the consumer thread will exit once it reaches an error. 
The part 2 program was more complex because it needed sections for file reading, multiple threads, user input, and lock implementation.  The file reading was done by going through the file and incrementing a counter so i could create an array of the proper size.  The file was read again to have the values stored in this new array.  The user is able to input values for how long the program runs.  This is done by a sleep process at the end after the threads have been created.  This however will not account for the time it takes to create the threads, but that should be mostly trivial.  The program also allows input for number of producer threads and number of consumer threads.  I borrowed my thread creation from the first part and implemented a for loop.  The functions for produce and consume are very different in this part.  I used a random number generator function to make each thread wait between executions for a maximum of 10 seconds.  Each thread would also be prevented from executing if they were locked out of the process.     I confirmed that multiple threads were doing the work by listing the thread IDs whenever a value was inserted or removed from the buffer.  I considered making the buffer larger than 10, but I read from the Q and A that it didn't really matter so i kept it at 10.  I also labeled the critical sections of each of these functions and implemented the locks there.  The program shows jump of processing between threads proving that the context switching occurs.  
